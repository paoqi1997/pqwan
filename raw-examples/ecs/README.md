# ECS

ECS，即 Entity-Component-System（实体-组件-系统）的缩写，其模式遵循 “组合优于继承” 的原则，
游戏内的每一个基本单元都是一个实体，每个实体又由一个或多个组件组成，每个组件仅包含代表其特性的数据（即组件中不包含任何方法）。

## 基本构成

+ E (Entity)

实体只是一个概念上的定义，一般指存在于游戏世界中的一个独特物体，是一系列组件的集合。
为了方便区分不同的实体，在代码层面上一般用一个 ID 来进行表示。所有组成这个实体的组件都会被这个 ID 标记，从而明确哪些组件属于该实体。

由于其是一系列组件的集合，因此完全可以在运行时动态地为实体添加一个新的组件或者将某个组件从实体中移除。
比如角色实体因为被怪物的束缚技能命中而暂时失去移动能力，只需简单地将移动组件从该角色身上移除，便可以达到无法移动的效果了。

+ C (Component)

组件是一堆数据的集合，它没有方法，即不存在任何行为，只用来存储状态。
一个经典的实现是：每个组件都继承（或实现）同一个基类（或接口），通过这样的处理，我们能够非常方便地在运行时动态添加、识别和移除组件。

每个组件的意义在于描述实体的某一个特性。例如 PositionComponent（位置组件），其拥有 x 和 y 两个数据，用来描述实体的位置信息，
拥有 PositionComponent 的实体便可以说在游戏世界中拥有了一席之地。

我们还可以用空组件（不含任何数据的组件）对实体进行标记，从而在运行时动态地识别它。
比如 EnemyComponent 这个组件，它不包含任何数据，拥有这个组件的实体将被标记为敌人。

+ S (System)

系统就是对拥有一个或多个相同组件的实体集合进行操作的工具，它只有行为，没有状态，所以它不应该存放任何数据。

假如现在拥有一个角色实体，其拥有位置和速度组件，那要怎么根据实体当前的速度去刷新其位置呢？
这个时候 MoveSystem（移动系统）登场，它可以得到所有拥有位置和速度组件的实体集合，然后遍历这个集合，
根据每个实体当前的位置和速度，通过物理引擎去计算该实体应当所处的位置，并刷新该实体位置组件的值，至此角色实体的移动就完成了。

如果一个实体同时拥有位置和速度组件，我们就认为该实体拥有移动能力，因此移动系统可以去刷新每一个符合要求的实体的位置。
当角色暂时不能移动时，我们只要将速度组件从该实体中移除，移动系统就得不到该角色的引用了；
同样的，如果我们希望游戏世界中的某一个实体能动起来，只需为其添加一个速度组件就🆗了。

一个系统关心实体拥有哪些组件是由我们决定的，通过一些手段，我们可以在系统中很快得到对应实体的集合。
